## 운영체제

#### 1. 프로세스와 스레드의 차이   
프로세스는 실행 중인 프로그램의 인스턴스이고, 스레드는 프로세스 내의 실행 단위이다.  
프로세스가 다른 프로세스에 접근하려면 IPC(파이프, 파일, 소켓 등을 이용)를 사용해야 한다.  
스레드는 다른 스레드와 Stack 영역을 제외한 메모리 영역을 공유해 통신 과정을 거칠 필요가 없어 효율적이다.

#### 2. LRU 캐싱에 대해 설명

페이지에서 제거할 때 가장 오랫동안 사용하지 않은 것을 제거하겠다는 알고리즘

**구현방법** 

1.  첫 번째 방법은 페이지에 저장된 데이터가 언제 사용되었는지를 알 수 있게하는 부분을 구현해서 제일 오랫동안 참조되지 않은 데이터를 제거하는 방법
2. 두 번째 방법은 페이지에 데이터를 큐형식으로 저장하는 방식입니다. 페이지 내에 필요한 데이터가 존재한다면 데이터를 페이지 내에서 제거하고 맨 위로 다시 올리고, 만약 데이터가 존재하지 않는다면 바로 입력하여 맨 아래에 있는 데이터를 삭제하는 과정을 통해 LRU 를 구현
3. 세번째 방법은 set과 list를 이용한 방법. set을 통해 존재하는 데이터를 확인 새로운 데이터 추가시 기존데이터는 삭제후 새로추가. 

#### 3. Race Condition
#### 4. Race Condition을 제어하는 방법
#### 5. 데드락이란
 둘 이상의 프로세스들이 자원을 점유한 상태에서 서로 다른 프로세스가 점유하고 있는 자원을 요구하며 무한정 기다리는 상황이다. 
 - 데드락의 4가지 조건
 1. 비선점 (Nonpreemptive) : 다른 프로세스의 자원을 뺏을 수 없음.
 1. 순환 대기 (Circular wait) : 두 개 이상의 프로세스가 자원 접근을 기다릴 때, 관계가 순환적 구조.
 1. 점유 대기 (Hold & Wait) : 공유 자원에 대한 접근 권한을 가진 채로 다른 자원에 대한 접근 권한을 요구.
 1. 상호 배제(Mutual Exclusion) : 한 번에 한 프로세스만 공유 자원에 접근 가능하며, 접근 권한이 제한적일 경우.  

#### 6. 데드락의 해결 방법

* 교착상태 예방(prevention), 회피(avoidance), 발견(detection), 회복(recovery).

* 예방 

  * 교착 상태 발생 조건 중 하나를 제거함으로써 해결하는 방법

  * | **상호 배제 (Mutual exclusion) 부정** | - 여러 개의 프로세스가 공유 자원을 사용할 수 있도록 한다. (하지만 동기화 문제가 다시 나타날 듯) |
    | ------------------------------------- | ------------------------------------------------------------ |
    | **점유 대기 (Hold and wait) 부정**    | - 프로세스가 실행되기 전 필요한 모든 자원을 할당한다. (이미 모든 자원을 가진 채 시작하여 다른 자원을 wait할 필요가 없다) |
    | **비선점 (No preemption) 부정**       | - 자원을 점유하고 있는 프로세스가 다른 자원을 요구할 때 점유하고 있는 자원을 반납하고, 요구한 자원을 사용하기 위해 기다리게 한다. |
    | **순환 대기 (Circular wait) 부정**    | - 자원에 고유한 번호를 할당하고, 번호 순서대로 자원을 요구하도록 한다. |

* 회피 
  * 회피 기법은 교착상태가 발생할 가능성을 배제하지 않고 교착상태가 발생하면 적절히 피해나가는 방법으로, 주로 **은행원 알고리즘(Banker’s Algorithm)** 이 사용
* 발견
  * 교착상태 발견 기법은 시스템에 교착상태가 발생했는지 점검하여 교착상태에 있는 프로세스와 자원을 발견하는 것을 의미합니다.
* 회복
  * 교착상태 회복 기법은 교착상태를 일으킨 프로세스를 종료하거나 교착상태의 프로세스에 할당된 자원을 선점하여 프로세스나 자원을 회복하는 것을 의미합니다.

#### 7. 인터럽트와 트랩

#### 8. Process 상태 변화 과정
[프로세스 상태 전이도](https://media.vlpt.us/images/fldfls/post/c1bdd63d-74a4-4b77-a532-d63f8ee9254c/image.png)    
Submit - Hold - Ready - Run - Wait/Exit    
    

- Submit: 작업을 처리하기 위해 사용자가 작업을 시스템에 제출한 상태.    
- Hold: 제출된 작업이 스풀 공간인 디스크의 할당 위치에 저장된 상태.    
=> Spooling: hold 단계에서 상대적으로 느린 입출력장치의 처리속도를 보완하기 위해 입출력 데이터를 직접 장치에 보내지 않고 나중에 한꺼번에 입출력하기 위해 디스크에 저장하는 과정.    
- Ready: 프로세스가 프로세서를 할당받기 위해 준비상태 큐에서 실행을 준비하는 단계. Hold에서 Ready로의 전이는 Job 스케줄러에 의해 수행됨.
=> Dispatch: Ready 상태에서 대기하고 있는 프로세스 중 하나가 프로세서를 할당받아 Run 상태로 전이되는 과정.
- Run: 프로세스가 프로세서를 할당받아 실행되는 상태.  
- Wait(Block): 프로세스에 입출력 처리가 필요하면 잠시 프로세스가 중단되고, 완료될때까지 대기하는 상태.   
=> Wake up: Wait 상태에서 Ready 상태로 전이되는 과정
- Exit(Terminated): 프로세스의 실행이 끝나고 프로세스의 할당이 해제된 상태  

#### 9. 페이징이란

하나의 프로세스가 사용하는 메모리 공간이 연속적이어야 한다는 제약을 없애는 메모리 관리 방법입니다. 외부 단편화와 압축 작업을 해소 하기 위해 생긴 방법론으로, 물리 메모리는 Frame 이라는 고정 크기로 분리되어 있고, 논리 메모리(프로세스가 점유하는)는 페이지라 불리는 고정 크기의 블록으로 분리됩니다.

페이징 기법을 사용함으로써 논리 메모리는 물리 메모리에 저장될 때, 연속되어 저장될 필요가 없고 물리 메모리의 남는 프레임에 적절히 배치됨으로 **외부 단편화를 해결할 수 있는 큰 장점** 이 있습니다.

단점은 **내부 단편화 문제는 페이징으로 해결해주지 못합니다.**

>  예를들어 페이지는 디폴트 크기가 4KB입니다. 그런데 전체크기가 11KB인 프로세스이 있을때 4KB 블럭씩 나누게 되면 총 3블럭이 나오지만 1블럭은 기본크기인 4KB를 다채우지못 하여 내부 단편화가 발생이 되는것입니다.

#### 10. 페이지 교체 알고리즘의 종류 설명
#### 11. 메모리구조에대해서 설명하시오.
- UNIX  
Code - Data - BSS - Heap - Stack  
=> Code: 기계어로 된 코드가 저장되는 메모리.    
=> Data: 전역 변수같이 컴파일 단계에서 초기화되고, 프로그램 종료 단계에 해제되는 메모리.  
=> BSS: 초기화되지 않은 변수의 default 값을 저장하는 메모리.  
=> Heap: 필요에 의해 메모리를 동적 할당할 수 있는 메모리.  
=> Stack: 프로그램이 자동으로 사용하는 임시 메모리. 지역 변수, 리턴값이 임시로 저장된다. 함수 호출시 생성되고 종료시 반환된다.  

#### 12. 뮤텍스와 세마포어의 차이.

- 세마포어는 공유 자원에 **세마포어의 변수만큼의 프로세스(또는 쓰레드)가 접근**할 수 있습니다. 반면에 뮤텍스는 **오직 1개만의 프로세스(또는 쓰레드)만 접근**할 수 있습니다.
- 현재 수행중인 프로세스가 아닌 **다른 프로세스가 세마포어를 해제할 수 있습니다.** 하지만 뮤텍스는 **락(lock)을 획득한 프로세스가 반드시 그 락을 해제**해야 합니다.

> 세마포어의 변수 -> 공유자원의 개수를 나타내는 변수.

> 0과 1의 값의 값만 갖는 세마포어 -> **binary semaphore**
>
> 도메인 제한이 없는 세마포어 (0,1뿐만아니라 2,3,4 등의 값들 또한 가질수 있는) -> **counting semaphore**

#### 13. 커널모드와 유저모드에 대해서 설명.


#### 14. Round Robin에 대해 설명.

Round Robin은 CPU Job Scheduling 기법으로, **선점형 스케줄링**방식이다.  
프로세스에 동일한 할당 시간만큼 순서대로 CPU를 할당한다. 응답시간이 빠르며, 모든 프로세스가 공정하게 CPU를 할당받을 수 있음을 보장한다.   
- round robin DNS    
로드밸런싱을 사용하지 않고 도메인 레코드를 조회하는 시점에서 여러 대의 서버로 트래픽을 분산하는 기법이다.  
헬스 체크를 하지 않아 특정 웹 서버에 문제가 생겨 서비스가 불가해도 알지 못한다는 단점이 있다. 무중단 서비스에는 적합하지 않다.

#### 15. PC(Program Counter) 역할

#### 16. 세그멘테이션이란?

#### 17. 가상 메모리란?   

가상 메모리는 프로세스에서 실제로 사용되는 영역만 메모리에 적재해 적재하는 총 용량을 줄이는 기법이다. 
가상 메모리의 크기는 cpu의 비트로 표현할 수 있는 주소 값의 최대이다. ex. 32bit CPU의 경우 4GB, 64bit CPU는 8TB 
프로세스 내의 개별 페이지들은 페이저에 의해 관리된다.  

#### 18. 동기와 비동기의 차이

#### 19. critical section의 3요소.

#### 20. RAID

#### 21. Thrashing과 해결법 설명    
Thrashing은 메모리에 페이지 부재율이 높은 것을 의미하며, 심각한 성능 저하를 초래한다.   
CPU 이용률이 낮을 때 운영체제는 새로운 프로세스를 추가하는데, 이때 전역 페이지 교체 알고리즘을 사용한다. 
이로 인해 교체되어버린 페이지를 필요로 하는 프로세스에 페이지 폴트가 발생하고, 다른 프로세스에서 부족한 프레임을 가져오게 되어 연쇄적으로 페이지 폴트가 발생한다.
해결 방법은 한 프로세스가 Thrashing을 유발했을 때, 다른 프로세스로부터 프레임을 뺏어올 수 없도록 하거나, 각 프로세스가 필요로 하는 최소한의 프레임 개수를 보장하는 것이다.   

#### 22. IPC와 구현 방법

#### 23. 스케줄러 종류 3가지
- 장기 스케줄러/잡 스케줄러    
: 디스크와 메모리 사이의 스케줄링을 담당. (ready)    
- 단기 스케줄러/CPU 스케줄러    
: 메모리와 CPU 사이의 스케줄링을 담당. (running)    
- 중기 스케줄러/스와퍼    
: 여유 공간을 마련하기 위해 프로세스를 메모리에서 디스크로 보내는 역할
----

#### 24. Blocking/Non-Blocking IO와 동기/비동기 IO 차이    
동기/비동기는 인터럽트 발생으로 인한 제어권 반환 시점에 중점을 두고, Blocking/Non-bloking은 제어권 자체에 중점을 둔다는 점에서 차이가 있다. 비동기와 Non-Bloking 모두 즉시 제어권을 반납하지만, 동기는 입출력 완료 시점과 결과 반환 시점이 불일치하고 Non-Blocking은 일치한다 (빈 값이라도 결과를 먼저 반환).    
+ 비동기 구현    
: 자바스크립트에서 async, await 키워드나 콜백 함수로 비동기 처리를 할 수 있다. async 키워드와 함께 선언안 함수 내부에서는 await 문법을 사용할 수 있는데, async 함수의 실행 후 반환 값은 Promise이다. Promise는 대기, 성공, 실패 3단계로 나뉘며, 성공/실패 같이 결과가 나왔을 경우 값이 지정된다.

#### 25. x86과 x64 차이

#### 26. 콘보이 현상이란? 콘보이 현상이 발생될 수 있는 cpu 스케줄러 알고리즘은?    
콘보이 현상이란 작업 시간이 긴 프로세스가 먼저 큐에 도착해서 다른 프로세스의 실행 시간이 전부 늦춰져 효율성을 떨어뜨리는 현상이다. FCFS(First Come First Start) 스케줄링 알고리즘은 비선점으로, 순차적으로 먼저 큐에 들어온 작업부터 실행하므로 콘보이 현상이 발생할 수 있다.

#### 27. 선점형 스케쥴링과 비선점형 스케줄링의 차이

#### 28. context switching 이란?

#### 29. 논리적 주소와 물리적 주소의 차이

#### 30. 메모리 계층구조 설명

#### 31. 캐시 메모리란?

#### 32. 지역성 두가지 설명

#### 33. fork(); fork(); fork(); 시 프로세서의 갯수는 ?

#### 34. spin lock, busy waiting에 대한 설명

#### 35. 캐시 매핑 방식 3가지

#### 36. 프로세스와 관련된 시스템콜 함수 아는대로 설명

#### 37. 중기 스케줄러로 인해 추가된 프로세스 상태 2가지 설명

#### 38. 컴파일러와 인터프리터의 차이

#### 39. 메모리 할당 알고리즘 First fit, Next fit, Best fit의 결과

#### 40. 커널에 대해서 아는대로 설명

#### 41. 메모리 할당방식을 연속, 불연속 나눠서 설명 

#### 42. 가상 메모리 설명

#### 43. 가상 머신 설명
