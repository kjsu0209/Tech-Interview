## [자료구조]()

-------
### 1. 스택과 큐 설명

- 공통점: 선형 자료구조, 배열과 연결리스트 등을 사용해 구현할 수 있음.
- 차이점: 스택은 선입후출(LIFO)의 방식. 큐는 선입선출(FIFO)의 방식. 파이썬 리스트는 스택만 지원한다. 스택 2개로 큐를 구현할 수 있다.

### 2. 배열과 연결 리스트의 장단점
### 3. 연결 리스트에서 한번에 중간값을 찾을 수 있는 방법은?
### 4. 원형 연결 리스트인지 확인할 수 있는 방법은?

투포인터를 이용하여 한개의 포인터는 두개씩 이동, 한개의 포인터는 한개씩 이동하여 두 포인터가 만나게 된다면 리스트가 원형임을 확인할 수 있습니다.

### 5. 1에서 100까지의 정수가 있는 배열에서 한개가 중복되었다. 어떻게 찾을까?

1에서 n까지 정수를 더한 값은 n(n-2)/2이다. 배열 안의 숫자를 모두 더한 값에 이 값을 빼면 중복된 값을 찾을 수 있다.
=> n이 매우 큰 수일 경우, 이진수로 각 수가 나타났는지 체크하는 방법이 있다.

### 6. 자바에서 문자열을 뒤집는 방법은?
### 7. 이진 탐색 트리 설명
### 8. 해시 테이블에서 Collision발생 시 해결법

해시에서는 충돌이 발생 할 수도 있는데 최악의 경우에는 O(N), 일반적으로 잘 구현 된 경우에는 O(1)의 시간 복잡도를 가지게 됩니다.

충돌의 해결방식은 **Chaining, Open addressing** 이 있습니다.

- **Chaining** : 같은 주소로 해슁되는 원소를 모두 하나의 연결리스트에 매달아 관리하는 방법 입니다.
  - 장점은 연결리스트만 사용하면 되기때문에 복잡한 계산식을 사용할 필요가 개방주소법에 비해 상대적으로 적습니다.
  - 해시테이블이 채워질수록 성능저하가 발생할 가능성이 높습니다.
- **Open addressing** : 충돌 발생시 다른 버킷에 저장하는 방식입니다.
  - 다른버킷을 선택하는 방법
    - **Linear Probing (선형 탐색)** : 해시 충돌 시 다음 버킷, 혹은 몇개를 건너뛰어 데이터를 삽입하는 방식.
    - **Quadratic Probing (제곱 탐색)** : 해시 충돌 시 다음 버킷, 혹은 몇개를 건너뛴 버킷에 데이터를 삽입하는 방식.
    - **Double Hashing** : 해시 충돌시 다른 해시함수를 한번 더 적용한 결과를 이용하는 방식.
  - 장점은 삽입 삭제시 오버헤드가 적고 저장할 데이터가 적을때는 유리합니다.

### 9. 그래프와 트리 차이점

- 그래프: 노드와 각 노드를 이어주는 간선으로 구성된 자료구조. 길찾기에 이용됨.
- 트리: 그래프의 일종이지만, 간선의 방향성이 있고, 사이클이 되면 안된다. 루트노드가 아닌 노드는 모두 부모 노드를 하나씩 갖고 있다. 자식 노드는 최대 2개까지.

### 10. 우선순위 큐 구현방법 설명
### 11. 해시 테이블 설명
### 12. 배열과 연결리스트의 삽입 삭제 시간 복잡도 설명

1. 배열에서의 삽입 삭제는 **O(N)** 타임이 소요됩니다. 왜냐하면 삽입이나 이후 요소들을 밀고 당기는 과정이 포함되기 때문입니다.
2. 하지만 연결리스트의 삽입 삭제는 **O(1)** 이 소요됩니다. 삽입위치의 전후 포인터만 조정해주면 되기 때문입니다.

### 13. 문자열 검색을 위한 자료구조와 이에 대한 장단점

Trie 자료구조
- 장점: 주어진 배열의 길이가 길어도 검색할 문자열의 길이만큼 탐색한다.
- 단점: 주어진 배열 안의 문자열의 길이가 길 경우 메모리 공간을 많이 차지한다.

### 14. 균형 이진 트리의 시간 복잡도
### 15. 스택 두개로 큐를 만드는 방법
### 16. n개의 배열에서 k번째로 큰 수를 찾는 방법

1. 퀵소트의 pivot찾기를 활용합니다. 
   1. pivot을 기준으로 좌측의 수들은 pivot보다 작은수 우측의 수들은 pivot 보다 큰 수 이므로 좌, 우측의 정렬 여부와 상관없이 해당 pivot의  위치는 확정적이므로 pivot의 인덱스가 k-1(인덱스시작이 0이라고 했을때)로 잡히는 경우 k번째 큰 수 라고 할 수 있습니다.
2. max heap을 이용합니다. 
   1. tree 의 크기가 k가 될 때 까지 입력을 받고 k보다 큰경우 heap에 넣은뒤 한개 씩 삭제하여 tree의 크기를 k로 유지하게합니다. 
   2. 그렇게 다 입력을 받은 경우 루트노드에 있는 값이 k번째로 큰 수입니다.

### 17. 최소 스패닝 트리(Minimum Spanning Tree)에 대해서 설명해주세요.

MST는 그래프의 Spanning Tree중 간선의 가중치 합이 최소인 Spanning Tree를 의미한다.
여기서 Spanning Tree는 루프가 없고 모든 그룹 노드를 포함하고 있어야 한다.
- 대표적인 알고리즘
- Kruskal's (O(E log E))
1. 모든 간선을 무게에 따라 오름차순으로 정렬
2. 가장 작은 간선을 뽑고, 간선이 신장 트리에서 사이클을 이루는지 확인한다. 만약 사이클이 생기지 않는다면 간선을 포함, 아닐 경우에는 삭제.
3. 신장 트리의 간선이 V-1이 될 때까지 2를 반복.
- Prim(O(E log V) : 간선을 하나씩 이어나가며 MST를 만들어나가는 알고리즘.

### 18. selection sort란?
### 19. Insertion Sort란?
### 20. Merge Sort란?
- 머지소트의 공간복잡도를 O(n/2)로 줄이는 방법
1. 필요없는 부분을 제외한다.
정렬해야할 그룹이 left = {1, 2, 4}, right = {3, 5, 6} 이고 배열에 {1, 2, 4, 3, 5, 6} 순서로 존재할 때 진짜 정렬해야할 부분은 2, 4, 3 이 있는 부분이다.
즉 left에서 right[0] 보다 큰 부분 부터 right 에서 left[last] 보다 작은 부분 까지다.

2. 필요한 데이터만 복사한다.
정렬해야할 그룹이 left = {3, 4, 5}, right = {1, 2} 일때 임시 버퍼를 buffer[5] 즉 {x, x, x, x, x}의 공간을 할당받지 않고 개수가 많은쪽의 데이터의 크기만큼만 복사한다.(여기서는 left)
그렇게 되면 정렬은 다음과 같이 진행할 수 있다.

buffer = {3, 4, 5} //임시로 할당되는 공간  
right = {1, 2} //개념적 공간임 사용하는 공간은 array의 공간을 사용하되 구분짓기 위한  
array = {3, 4, 5, 1, 2} //현재 배열에 들어가있는 데이터의 순서  

이 때 정렬은 left의 데이터를 가져왔으므로 앞에서부터 수행해야 한다. (right의 공간을 가져왔으면 뒤에서부터 채워넣어야함)

buffer = {3, 4, 5}  
right = {2}  
array = {1, 4, 5, 1, 2}  
 
buffer = {3, 4, 5}  
right = {}  
array = {1, 2, 5, 1, 2}  
이 때 right가 비게 되므로 기존 Merge Sort의 방식 그대로인 남아있는 곳의 데이터를 모두 복사하는 방식으로 진행  

buffer = {}  
right = {}  
array = {1, 2, 3, 4, 5}  

O(n/2)의 공간 복잡도를 가지게 되지만 Big-O 표기를 하게 되면 O(n)이라고 표현하게 된다.   
그냥 이런 방법도 있다는걸 알아 두시면 좋을꺼 같아요 어짜피 표현은 둘다 O(n)이라고 표현하게 되겠지만요..  

### 21. quick sort란?

퀵 소트 또한 **분할 정복을 이용하여 정렬을 수행하는 알고리즘** 입니다.

**pivot point 라는 기준이되는 값을 하나 설정하여 이값을 기준으로 작은 값은 왼쪽 큰값은 오른쪽으로 옮기는 방식으로 정렬을 진행합니다.**

이를 반복하여 분할된 배열의 크기가 1이되면 모두 정렬이 된 것 입니다.

여기서 pivot point는 주로 배열의 값중 맨 앞이나 맨뒤, 중간 혹은 랜덤값으로 정하게 되는데 배열의 맨 앞값이나 맨 뒤의 값으로 정하는 경우 **정렬된 상태에서 최악의 케이스로 시간 복잡도 O(n^2)** 을 가지게 됩니다.

그래서 주로 **배열의 중간값이나 랜덤 값으로 pivot point** 를 잡습니다.

평균적인 시간 복잡도는 **O(nlogn)** 입니다.