## [자료구조]()

-------
### 1. 스택과 큐 설명

- 공통점: 선형 자료구조, 배열과 연결리스트 등을 사용해 구현할 수 있음.
- 차이점: 스택은 선입후출(LIFO)의 방식. 큐는 선입선출(FIFO)의 방식. 파이썬 리스트는 스택만 지원한다. 스택 2개로 큐를 구현할 수 있다.

### 2. 배열과 연결 리스트의 장단점
### 3. 연결 리스트에서 한번에 중간값을 찾을 수 있는 방법은?
### 4. 원형 연결 리스트인지 확인할 수 있는 방법은?
### 5. 1에서 100까지의 정수가 있는 배열에서 한개가 중복되었다. 어떻게 찾을까?

1에서 n까지 정수를 더한 값은 n(n-2)/2이다. 배열 안의 숫자를 모두 더한 값에 이 값을 빼면 중복된 값을 찾을 수 있다.
=> n이 매우 큰 수일 경우, 이진수로 각 수가 나타났는지 체크하는 방법이 있다.

### 6. 자바에서 문자열을 뒤집는 방법은?
### 7. 이진 탐색 트리 설명
### 8. 해시 테이블에서 Collision발생 시 해결법
### 9. 그래프와 트리 차이점

- 그래프: 노드와 각 노드를 이어주는 간선으로 구성된 자료구조. 길찾기에 이용됨.
- 트리: 그래프의 일종이지만, 간선의 방향성이 있고, 사이클이 되면 안된다. 루트노드가 아닌 노드는 모두 부모 노드를 하나씩 갖고 있다. 자식 노드는 최대 2개까지.

### 10. 우선순위 큐 구현방법 설명
### 11. 해시 테이블 설명
### 12. 배열과 연결리스트의 삽입 삭제 시간 복잡도 설명
### 13. 문자열 검색을 위한 자료구조와 이에 대한 장단점

Trie 자료구조
- 장점: 주어진 배열의 길이가 길어도 검색할 문자열의 길이만큼 탐색한다.
- 단점: 주어진 배열 안의 문자열의 길이가 길 경우 메모리 공간을 많이 차지한다.

### 14. 균형 이진 트리의 시간 복잡도
### 15. 스택 두개로 큐를 만드는 방법
### 16. n개의 배열에서 k번째로 큰 수를 찾는 방법
### 17. 최소 스패닝 트리(Minimum Spanning Tree)에 대해서 설명해주세요.

MST는 그래프의 Spanning Tree중 간선의 가중치 합이 최소인 Spanning Tree를 의미한다.
여기서 Spanning Tree는 루프가 없고 모든 그룹 노드를 포함하고 있어야 한다.
- 대표적인 알고리즘
- Kruskal's (O(E log E))
1. 모든 간선을 무게에 따라 오름차순으로 정렬
2. 가장 작은 간선을 뽑고, 간선이 신장 트리에서 사이클을 이루는지 확인한다. 만약 사이클이 생기지 않는다면 간선을 포함, 아닐 경우에는 삭제.
3. 신장 트리의 간선이 V-1이 될 때까지 2를 반복.
- Prim(O(E log V) : 간선을 하나씩 이어나가며 MST를 만들어나가는 알고리즘.

### 18. selection sort란?
### 19. Insertion Sort란?
### 20. Merge Sort란?
- 머지소트의 공간복잡도를 O(n/2)로 줄이는 방법
1. 필요없는 부분을 제외한다.
정렬해야할 그룹이 left = {1, 2, 4}, right = {3, 5, 6} 이고 배열에 {1, 2, 4, 3, 5, 6} 순서로 존재할 때 진짜 정렬해야할 부분은 2, 4, 3 이 있는 부분이다.
즉 left에서 right[0] 보다 큰 부분 부터 right 에서 left[last] 보다 작은 부분 까지다.

2. 필요한 데이터만 복사한다.
정렬해야할 그룹이 left = {3, 4, 5}, right = {1, 2} 일때 임시 버퍼를 buffer[5] 즉 {x, x, x, x, x}의 공간을 할당받지 않고 개수가 많은쪽의 데이터의 크기만큼만 복사한다.(여기서는 left)
그렇게 되면 정렬은 다음과 같이 진행할 수 있다.

buffer = {3, 4, 5} //임시로 할당되는 공간  
right = {1, 2} //개념적 공간임 사용하는 공간은 array의 공간을 사용하되 구분짓기 위한  
array = {3, 4, 5, 1, 2} //현재 배열에 들어가있는 데이터의 순서  

이 때 정렬은 left의 데이터를 가져왔으므로 앞에서부터 수행해야 한다. (right의 공간을 가져왔으면 뒤에서부터 채워넣어야함)

buffer = {3, 4, 5}  
right = {2}  
array = {1, 4, 5, 1, 2}  
 
buffer = {3, 4, 5}  
right = {}  
array = {1, 2, 5, 1, 2}  
이 때 right가 비게 되므로 기존 Merge Sort의 방식 그대로인 남아있는 곳의 데이터를 모두 복사하는 방식으로 진행  

buffer = {}  
right = {}  
array = {1, 2, 3, 4, 5}  

O(n/2)의 공간 복잡도를 가지게 되지만 Big-O 표기를 하게 되면 O(n)이라고 표현하게 된다.   
그냥 이런 방법도 있다는걸 알아 두시면 좋을꺼 같아요 어짜피 표현은 둘다 O(n)이라고 표현하게 되겠지만요..  

### 21. quick sort란?
