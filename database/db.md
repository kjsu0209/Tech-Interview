## 데이터베이스

#### 1. PK, FK, ER 모델이란?    
PK: row를 구분할 수 있는 후보키중 인덱스로서 사용되는 키
FK: 다른 테이블을 참조하기 위해 사용되는 키. 참조 무결성 제약조건에 의해 참조하는 테이블의 PK/UK이다.  
ER 모델: 데이터를 개체, 속성, 관계로 표현한 모델.

#### 2. SQL이란?

데이터베이스가 이해할 수 있는 질의 언어. 데이터를 보다 쉽게 검색하고 추가, 삭제, 수정같은 조작을 할 수 있도록 고안된 컴퓨터 언어.

#### 3. 인덱스 설명
#### 4. 트랜잭션이란?   
트랜잭션은 데이터베이스 시스템에서 처리되는 작업의 논리적 단위로, commit되거나 rollback된다.  
> **Spring의 트랜잭션**    
> Spring에서 Transaction은 두 개 이상의 쿼리를 한 작업으로 실행해야 할 때 사용된다.   
> @Transactional 어노테이션을 사용하고 싶은 메소드 에 붙이면 된다.   
> @Transactional 어노테이션을 이용해 트랜잭션을 처리하기 위해 내부적으로 AOP를 사용한다.  
> 스프링은 @Transactional 어노테이션이 적용된 빈 객체를 찾아서 프록시 객체를 생성한다.
> 이때 getBean 코드를 실행하면 프록시 객체를 리턴한다.
> 이 프록시 객체는 TransactionManager 객체를 사용해서 트랜잭션을 실행하고, 시작한 후 실제 객체의 메서드를 호출한다. 
> 성공적으로 실행되면 트랜잭션을 커밋한다.

#### 5. 트랜잭션의 성질을 말씀해 주세요.

* **Atomicity(원자성)**
  1. 트랜잭션의 연산은 데이터베이스에 모두 반영되든지 아니면 전혀 반영되지 않아야 한다.
  2. 트랜잭션 내의 모든 명령은 반드시 완벽히 수행되어야 하며, 모두가 완벽히 수행되지 않고 어느하나라도 오류가 발생하면 트랜잭션 전부가 취소되어야 한다.
* **Consistency(일관성)**
  1. 트랜잭션이 그 실행을 성공적으로 완료하면 언제나 **일관성 있는 데이터베이스 상태로 변환** 한다.
     - 여기서 일관성이 있어야 한다는 것은 트랜잭션의 작업 처리결과가 일관성이 있어야 한다는 것.
  2. 시스템이 가지고 있는 고정요소는 트랜잭션 수행 전과 트랜잭션 수행 완료 후의 상태가 같아야 한다.
* **Isolation(독립성,격리성)**
  1. 둘 이상의 트랜잭션이 동시에 병행 실행되는 경우 어느 하나의 트랜잭션 실행중에 다른 트랜잭션의 연산이 끼어들 수 없다.
  2. 수행중인 트랜잭션은 완전히 완료될 때까지 다른 트랜잭션에서 수행 결과를 참조할 수 없다.
* **Durablility(영속성,지속성)**
  1. 성공적으로 완료된 트랜잭션의 결과는 시스템이 고장나더라도 영구적으로 반영되어야 한다.

#### 6. 정규화란 무엇인가
#### 7. NoSQL이란?   
Non relational SQL, Not Only SQL이라고도 불리며, 전통적인 관계형 DB보다 덜 제한적인 일관성 모델을 사용한다.     
- 관계형 모델을 사용하지 않으며 테이블간의 조인 기능 없음
- 직접 프로그래밍을 하는 등의 비SQL 인터페이스를 통한 데이터 액세스
- 대부분 여러 대의 데이터베이스 서버를 묶어서(클러스터링) 하나의 데이터베이스를 구성
- 관계형 데이터베이스에서는 지원하는 Data처리 완결성(Transaction ACID 지원) 미보장
- 데이터의 스키마와 속성들을 다양하게 수용 및 동적 정의 (Schema-less)
- 데이터베이스의 중단 없는 서비스와 자동 복구 기능지원
- 확장성, 가용성, 높은 성능

#### 8. Transaction Isolation Level 이란?

동시에 여러 트랜잭션이 처리될 때 특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수 있도록 허용할지 말지를 결정하는 것.

- READ UNCOMMITTED
  - 각 트랜잭션에서의 변경 내용이 `COMMIT`이나 `ROLLBACK` 여부에 상관 없이 다른 트랜잭션에서 값을 읽을 수 있다.
  - `DIRTY READ`현상 발생
    - 트랜잭션이 작업이 완료되지 않았는데도 다른 트랜잭션에서 볼 수 있게 되는 현상
- READ COMMITTED
  - RDB에서 대부분 기본적으로 사용되고 있는 격리 수준이다.
  - Dirty Read와 같은 현상은 발생하지 않는다.
  - 실제 테이블 값을 가져오는 것이 아니라 Undo 영역에 백업된 레코드에서 값을 가져온다.
- REPEATABLE READ
  - MySQL에서는 트랜잭션마다 트랜잭션 ID를 부여하여 트랜잭션 ID보다 작은 트랜잭션 번호에서 변경한 것만 읽게 된다.
  - Undo 공간에 백업해두고 실제 레코드 값을 변경한다
    - 백업된 데이터는 불필요하다고 판단하는 시점에 주기적으로 삭제한다.
    - Undo에 백업된 레코드가 많아지면 MySQL 서버의 처리 성능이 떨어질 수 있다.
- SERIALIZABLE
  - 가장 단순한 격리 수준이지만 가장 엄격한 격리 수준
  - 성능 측면에서는 동시 처리성능이 가장 낮다.
  - `SERIALIZABLE`에서는 `PHANTOM READ`가 발생하지 않는다.하지만.. 데이터베이스에서 거의 사용되지 않는다.


+ MySQL : level 2
+ Oracle, SQL server : level 1

#### 9. inner join과 outer join 차이

#### 10. DELETE, TRUNCATE, DROP 차이

#### 11. 데이터 추상화 3단계    

-----

#### 12. DB에서 slow query가 발생했을 경우 어떻게 대처하는지

#### 13. ORM이란?

#### 14. 쿼리 옵티마이저 설명

#### 15. 데이터베이스 샤딩이란?

#### 16. 무결성에 대해 설명해주세요

#### 17. 역정규화를 하는 이유?

#### 18. RDS의 특징 설명

#### 19. having과 where 차이

#### 20. group by의 역할

#### 21. commit/ rollback 설명
